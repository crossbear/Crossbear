<%--
Copyright (c) 2011, Thomas Riedmaier, Technische Universität München
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Crossbear nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THOMAS RIEDMAIER BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

--%>
<%@ page import="crossbear.*,crossbear.messaging.*,org.bouncycastle.jce.provider.BouncyCastleProvider,java.security.*,java.io.OutputStream"
	 language="java"
	contentType="application/octet-stream"
	%><%!
	
	/*
	* verifyCert.jsp takes as input a CertVerifyRequest-message. If the request is valid a check is performed if it has been
	* issued for the first time. If that is the case it is processed and the result is then stored in a cache. If not the 
	* reply is read from cache and sent to the client. Processing roughly consists of the following steps:
	* - store the certificate's observation
	* - query the server for it's certificate chain and store it's observation
	* - compare the two certificates
	* - generate a rating based on that
	* - send the rating (and it's details) to the client
	* - if the certificates don't match:  generate a hunting task.
	*/
	
	/* 
	* The CertificateManager loads all certificates from the local keystore in order to be able to calculate as many
	* certificate chains as possible. Doing so takes some time and is therefore only done once in jspInit. To use the loaded
	* keys every time verifyCert.jsp is loaded a global CertificateManager object is created.
	*/
	private CertificateManager cm;

	/*
	* The Crossbear server uses several caches to speed up requests processing:
	* - CertificateCache (contains the certificates that were recently observed by the server)
	* - CertVerifyResultCache (contains the results that were generated by this page in case they are requested multiple times)
	* - HuntingTaskListCache (contains the current list of hunting tasks)
	*
	* cacheValidity is the time in milliseconds that an entry stays valid in one of those caches
	*
	* SUGG: The cacheValidity could be adjusted dynamically based on the server's current load
	*/
	private int cacheValidity = 5 * 60 * 1000;
	
	// Properties and settings of the Crossbear server
	private Properties properties;
	
	/*
	* Old entries schould be removed from the caches. This is done once every thousand page loads.
	* The pageLoadCounter keeps track on how often the page has been loaded since the last purge of the cache.
	*/
	private int pageLoadCounter = 0;

	// Constructor-like functionality: Only performed the first time the page is loaded
	public void jspInit() {

		try {
			
			/*
			* Adding the bouncy castle Security Provider is required for the use of 
			* - "SHA256"-HMAC
			* - "AES/CBC/PKCS7Padding"-Symmetric Encryption
			* - "RSA/None/OAEPWithSHA1AndMGF1Padding"-Asymmetric Encryption
			* all of these are used in Crossbear.
			*/
			Security.addProvider(new BouncyCastleProvider());
					
			// Load the porperties and settings from the config file
			properties = new Properties("/var/lib/tomcat6/webapps/crossbear.properties");

			/*
			* As mentioned above the CertificateManager needs to load the local keystore on initilization.
			* This is done here.
			* 
			* In order to be able to look into all certificates that are part of any certificate chain these
			* certificates need to be put in the database also. This requires a database object.
			*
			* Since Crossbear uses Transactions there is no such thing as a global Database object. That again is
			* the reason why a new database connection is created to insert the certificates and closed afterwards.
			*/
			Database db = new Database(properties.getProperty("database.url"),properties.getProperty("database.user"),properties.getProperty("database.password"));
			cm = new CertificateManager(db,cacheValidity, properties.getProperty("keystore.password"));
			db.close();

		} catch (Exception e) {

			Logger.dumpExceptionToFile("/var/lib/tomcat6/webapps/fourhundredfourtythree/init.verifycert.error", e);

		}

	}
	%><%
	Database db = null;
	
	try {
		// Crossbear works on binary messages. To send these from the server to the client they need to be written into response.getOutputStream()
		OutputStream outStream = response.getOutputStream();
		
		//First of all try to decode the CertVerifyRequest sent by the client
		CertVerifyRequest cvr = CertVerifyRequest.readFromStream(request.getInputStream(), request.getRemoteAddr(), request.getLocalAddr());

		//If the decoding succedded open a database connection and create a CVRProcessor
		db = new Database(properties.getProperty("database.url"),properties.getProperty("database.user"),properties.getProperty("database.password"));
		CVRProcessor cvrp = new CVRProcessor(cvr, cm, db);
		
		/*
		* Under certain circumstances the Crossbear Firefox Plug-in sends duplicate requests. 
		* Processing these multiple times has two disadvantages:
		* 1) Higher server load
		* 2) Duplicates in Certobservations table.
		* Since it is beneficial to avoid both all generated CertVerifyResults are cached and resent if requested more than once.
		*
		* First: try to get the CertVerifyResult from cache
		*/
		byte[] reply = cvrp.getCachedCertVerifyResult();
		
		if(reply == null){

			// If that failed calculate the reply ...
			reply = cvrp.process().getBytes();
			
			//... and store it in the database
			cvrp.storeCertVerifyResultInCache(reply,cacheValidity);
		}

		// Send the reply to the client
		outStream.write(reply);
		
		// Occasionally purge the cache from old entries
		pageLoadCounter++;
		if(pageLoadCounter>1000){
			cvrp.purgeCache();
			
			pageLoadCounter = 0;
		}
		
		// Finally: Sent the reply to the client (flush the out buffer)
		response.flushBuffer();


	} catch (Exception e) {
		/*
		* None of the calls above catches exceptions. Whenever something went wrong (e.g. with decoding the client's request)
		* A exception is thrown and cought here. Since it's not very smart to tell attackers what went wrong a dummy reply is sent to them.
		*/
		out.println("Crossbear");

		// For debugging reasons: Log what went wrong
		Logger.dumpExceptionToFile("/var/lib/tomcat6/webapps/fourhundredfourtythree/processing.verifycert.error", e);

	} finally {
		if (db != null)
			db.close();
	}
%>