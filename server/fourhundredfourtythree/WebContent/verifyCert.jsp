<%--
/*
    This file is part of Crossbear.

    Crossbear is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Crossbear is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Crossbear.  If not, see <http://www.gnu.org/licenses/>.

    Original authors: Thomas Riedmaier, Ralph Holz (TU Muenchen, Germany)
*/

--%><%@ page import="crossbear.*,crossbear.messaging.*,org.bouncycastle.jce.provider.BouncyCastleProvider,java.security.*,java.io.OutputStream,java.io.File"
	 language="java"
	contentType="application/octet-stream"
	%><%!
	
	/*
	* verifyCert.jsp takes as input a CertVerifyRequest-message. If the request is valid a check is performed if it has been
	* issued for the first time. If that is the case it is processed and the result is then stored in a cache. If not the 
	* reply is read from cache and sent to the client. Processing roughly consists of the following steps:
	* - store the certificate's observation
	* - query the server for it's certificate chain and store it's observation
	* - compare the two certificates
	* - generate a rating based on that
	* - send the rating (and it's details) to the client
	* - if the certificates don't match:  generate a hunting task.
	*/
	
	/* 
	* The CertificateManager loads all certificates from the local keystore in order to be able to calculate as many
	* certificate chains as possible. Doing so takes some time and is therefore only done once in jspInit. To use the loaded
	* keys every time verifyCert.jsp is loaded a global CertificateManager object is created.
	*/
	private CertificateManager cm;

	/*
	* The Crossbear server uses several caches to speed up requests processing:
	* - CertificateCache (contains the certificates that were recently observed by the server)
	* - CertVerifyResultCache (contains the results that were generated by this page in case they are requested multiple times)
	* - HuntingTaskListCache (contains the current list of hunting tasks)
	*
	* cacheValidity is the time in milliseconds that an entry stays valid in one of those caches
	*
	* SUGG: The cacheValidity could be adjusted dynamically based on the server's current load
	*/
	private int cacheValidity = 5 * 60 * 1000;
	
	// Properties and settings of the Crossbear server
	private Properties properties;
	
	/*
	* Old entries schould be removed from the caches. This is done once every thousand page loads.
	* The pageLoadCounter keeps track on how often the page has been loaded since the last purge of the cache.
	*/
	private int pageLoadCounter = 0;

	// Constructor-like functionality: Only performed the first time the page is loaded
	public void jspInit() {

		try {
			ServletContext sc = getServletContext();
			String contextPath = sc.getRealPath(File.separator);


			/*
			* Adding the bouncy castle Security Provider is required for the use of 
			* - "SHA256"-HMAC
			* - "AES/CBC/PKCS7Padding"-Symmetric Encryption
			* - "RSA/None/OAEPWithSHA1AndMGF1Padding"-Asymmetric Encryption
			* all of these are used in Crossbear.
			*/
			Security.addProvider(new BouncyCastleProvider());
					
			// Load the porperties and settings from the config file
			properties = new Properties(contextPath.concat("../../crossbear.properties"));

			/*
			* As mentioned above the CertificateManager needs to load the local keystore on initilization.
			* This is done here.
			* 
			* In order to be able to look into all certificates that are part of any certificate chain these
			* certificates need to be put in the database also. This requires a database object.
			*
			* Since Crossbear uses Transactions there is no such thing as a global Database object. That again is
			* the reason why a new database connection is created to insert the certificates and closed afterwards.
			*/
			Database db = new Database(properties.getProperty("database.url"),properties.getProperty("database.user"),properties.getProperty("database.password"));
			cm = new CertificateManager(db,cacheValidity, properties.getProperty("keystore.password"));
			db.close();

		} catch (Exception e) {

			Logger.dumpExceptionToFile("/tmp/fourhundredfourtythree.verifyCert.init.error", e);

		}

	}
	%><%
	Database db = null;
	
	try {
		// Crossbear works on binary messages. To send these from the server to the client they need to be written into response.getOutputStream()
		OutputStream outStream = response.getOutputStream();
		
		//First of all try to decode the CertVerifyRequest sent by the client
		CertVerifyRequest cvr = CertVerifyRequest.readFromStream(request.getInputStream(), request.getRemoteAddr(), request.getLocalAddr());

		//If the decoding succedded open a database connection and create a CVRProcessor
		db = new Database(properties.getProperty("database.url"),properties.getProperty("database.user"),properties.getProperty("database.password"));
		CVRProcessor cvrp = new CVRProcessor(cvr, cm, db);
		
		/*
		* Under certain circumstances the Crossbear Firefox Plug-in sends duplicate requests. 
		* Processing these multiple times has two disadvantages:
		* 1) Higher server load
		* 2) Duplicates in Certobservations table.
		* Since it is beneficial to avoid both all generated CertVerifyResults are cached and resent if requested more than once.
		*
		* First: try to get the CertVerifyResult from cache
		*/
		byte[] reply = cvrp.getCachedCertVerifyResult();
		
		if(reply == null){
			// Can we also cache the signature of the Message? Should be okay, since the message doesn't change much.
			MessageList ml = cvrp.process();
			SignatureMessage sigm = new SignatureMessage(ml.getBytes(),
								     properties.getProperty("pkey.keyStoreFile"),
								     properties.getProperty("pkey.keyStorePassword"),
								     properties.getProperty("pkey.alias"),
								     properties.getProperty("pkey.password"));
			ml.add(sigm);
			// If that failed calculate the reply ...
			reply = ml.getBytes();
			
			//... and store it in the database
			cvrp.storeCertVerifyResultInCache(reply,cacheValidity);
		}

		// Send the reply to the client
		outStream.write(reply);
		
		// Occasionally purge the cache from old entries
		pageLoadCounter++;
		if(pageLoadCounter>1000){
			cvrp.purgeCache();
			
			pageLoadCounter = 0;
		}
		
		// Finally: Sent the reply to the client (flush the out buffer)
		response.flushBuffer();


	} catch (Exception e) {
		/*
		* None of the calls above catches exceptions. Whenever something went wrong (e.g. with decoding the client's request)
		* A exception is thrown and cought here. Since it's not very smart to tell attackers what went wrong a dummy reply is sent to them.
		*/

		// For debugging reasons: Log what went wrong
		Logger.dumpExceptionToFile(properties.getProperty("logging.dir")+"/fourhundredfourtythree.verifyCert.processing.error", e);

	} finally {
		if (db != null)
			db.close();
	}
%>
